'use strict';

exports.__esModule = true;

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _testcafe = require('testcafe');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _testcafe.Selector)(function (complexSelector) {
    function validateSelector(selector) {
        if (selector !== void 0 && typeof selector !== 'string') throw new Error('If the selector parameter is passed it should be a string, but it was ' + eval('typeof selector')); // eslint-disable-line no-eval
    }

    function validateVueVersion(rootInstance) {
        var MAJOR_SUPPORTED_VUE_VERSION = 2;
        var vueVersion = parseInt(findVueConstructor(rootInstance).version.split('.')[0], 10);

        if (vueVersion < MAJOR_SUPPORTED_VUE_VERSION) throw new Error('testcafe-vue-selectors supports Vue version 2.x and newer');
    }

    /*eslint-disable no-unused-vars, no-eval*/
    function findVueConstructor(rootInstance) {
        // NOTE: Testcafe does not support a ClientFunction containing polyfilled functions. See list in
        // https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-runtime/src/definitions.js.
        // This is why, we use this hack.
        var Vue = eval('Object.getPrototypeOf(rootInstance)').constructor;

        while (Vue.super) {
            Vue = Vue.super;
        }return Vue;
    }
    /*eslint-enable no-unused-vars, no-eval*/

    function findFirstRootInstance() {
        var instance = null;
        var treeWalker = document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT, function () {
            return NodeFilter.FILTER_ACCEPT;
        }, false);

        while (!instance && treeWalker.nextNode()) {
            instance = treeWalker.currentNode.__vue__;
        }return instance;
    }

    function getComponentTagNames(componentSelector) {
        return componentSelector.split(' ').filter(function (el) {
            return !!el;
        }).map(function (el) {
            return el.trim();
        });
    }

    function getComponentTag(instance) {
        return instance.$options.name || instance.$options._componentTag || instance.$options.__file || '';
    }

    function isRef(selector) {
        return selector.indexOf('ref:') !== -1;
    }

    function getRef(selector) {
        if (selector.indexOf('ref:') === 0 && selector.split('ref:')[1]) return selector.split('ref:')[1];

        throw new Error('If the ref is passed as selector it should be in the format \'ref:ref-selector\'');
    }

    function getRefOfNode(node) {
        if (node.$vnode && node.$vnode.data) return node.$vnode.data.ref;
        return null;
    }

    function filterNodes(root, tags) {
        var foundComponents = [];

        function walkVueComponentNodes(node, tagIndex, checkFn) {
            if (checkFn(node, tagIndex)) {
                if (tagIndex === tags.length - 1) {
                    foundComponents.push(node.$el);
                    return;
                }

                tagIndex++;
            }

            for (var i = 0; i < node.$children.length; i++) {
                var childNode = node.$children[i];

                walkVueComponentNodes(childNode, tagIndex, checkFn);
            }
        }

        walkVueComponentNodes(root, 0, function (node, tagIndex) {
            if (isRef(tags[tagIndex])) {
                var ref = getRef(tags[tagIndex]);

                return ref === getRefOfNode(node);
            }
            return tags[tagIndex] === getComponentTag(node);
        });
        return foundComponents;
    }

    validateSelector(complexSelector);

    var rootInstance = findFirstRootInstance();

    if (!rootInstance) return null;

    validateVueVersion(rootInstance);

    if (!complexSelector) return rootInstance.$el;

    var componentTags = getComponentTagNames(complexSelector);

    return filterNodes(rootInstance, componentTags);
}).addCustomMethods({
    getVue: function getVue(node, fn) {
        function getData(instance, prop) {
            var result = {};

            (0, _keys2.default)(prop).forEach(function (key) {
                result[key] = instance[key];
            });

            return result;
        }

        function getProps(instance) {
            return getData(instance, instance.$options.props || {});
        }

        function getState(instance) {
            var props = instance._props || instance.$options.props;
            var getters = instance.$options.vuex && instance.$options.vuex.getters;
            var result = {};

            (0, _keys2.default)(instance._data).filter(function (key) {
                return !(props && key in props) && !(getters && key in getters);
            }).forEach(function (key) {
                result[key] = instance._data[key];
            });

            return result;
        }

        function getComputed(instance) {
            return getData(instance, instance.$options.computed || {});
        }

        function getComponentReference(instance) {
            return instance.$vnode && instance.$vnode.data && instance.$vnode.data.ref;
        }

        var nodeVue = node.__vue__;

        if (!nodeVue) return null;

        var props = getProps(nodeVue);
        var state = getState(nodeVue);
        var computed = getComputed(nodeVue);
        var ref = getComponentReference(nodeVue);

        if (typeof fn === 'function') return fn({ props: props, state: state, computed: computed, ref: ref });

        return { props: props, state: state, computed: computed, ref: ref };
    }
});